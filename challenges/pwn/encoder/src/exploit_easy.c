#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/buffer.h>

// compile with gcc -o exploit_easy exploit_easy.c -lssl -lcrypto

char * base64(const unsigned char *input, int length)
{
	BIO *bmem, *b64;
	BUF_MEM *bptr;

	b64 = BIO_new(BIO_f_base64());
	bmem = BIO_new(BIO_s_mem());
	b64 = BIO_push(b64, bmem);
	BIO_write(b64, input, length);
	BIO_flush(b64);
	BIO_get_mem_ptr(b64, &bptr);

	char *buff = (char *)malloc(bptr->length);
	memcpy(buff, bptr->data, bptr->length);
	buff[bptr->length] = 0;
	
	// remove new line
	buff[bptr->length - 1] = 0;
	length = bptr->length - 2;
	
	// remove =
	while (buff[length] == '=') {
		buff[length] = 0;
		length--;
	}

	BIO_free_all(b64);

	return buff;
}


int main(int argc, char *argv[]) {
	
	int i = 0;
	int debug = 0;
	
	if (argc < 2) {
		printf("Usage: %s [help|encode|decode]\n", argv[0]);
		exit(0);
	}
	
	for (i = 0; i < argc; i++){
		if (strcmp(argv[i], "--debug") == 0) {
			debug = 1;
		}
	}
	
	if (strcmp(argv[1], "help") == 0) {
		
		printf("%s help         : Print this help\n", argv[0]);
		printf("%s encode input : Encode your input with our magic algorithm (impossible to reverse)\n", argv[0]);
		printf("%s decode input : Decode your encoded secret\n", argv[0]);
		printf("%s --debug      : Print debug informations\n", argv[0]);
		printf("******************************************\n");
		printf("    Encoder : Development version 0.98    \n");
		printf("******************************************\n");
		
	} else if (strcmp(argv[1], "encode") == 0 && (argc > 2)) {
		
		char *b64encoded = base64(argv[2], strlen(argv[2]));
		if (debug) {
			printf("Step 1 : Running OpenSSL base64 encode\n");
			printf("Step 2 : ");
			printf("Running 'echo %s | rev' bash command\n", b64encoded);
		}
		
		unsigned int size = strlen(b64encoded) + 20;
		
		if (size < strlen(b64encoded)) {
			printf("WTF are you trying !");
			free(b64encoded);
			exit(0);
		}
		
		char * command = (char *)malloc(size);
		snprintf( command, size, "echo %s | rev", b64encoded);
		
		if (debug) {
			printf("Result : \n");
		}
		
		system(command);

		free(b64encoded);
		free(command);
	} else if (strcmp(argv[1], "decode") == 0) {
		printf("Not implemented !\nWait for Encoder version 1.0!\n");
	} else {
		printf("Usage: %s [help|encode|decode]\n", argv[0]);
	}

	return 0;
}